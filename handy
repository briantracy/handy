#!/usr/bin/env python

from sys import exit, argv
from os import access, R_OK, system
from os.path import isfile

directives = {}
DIRECTIVE_WAIT_FOR_INPUT = 'wait-for-input'

def main(args):
  # $ handy
  if len(args) == 1:
    usage()
    exit(0)

  # $ handy <handyfile>
  if len(args) == 2:
    output(parse(args[1]), None)
    exit(0)

  # $ hand <handyfile> <copy-program>
  if len(args) == 3:
    output(parse(args[1]), args[2])
    exit(0)

  # $ handy <handyfile> <copy-program> <command-number>
  if len(args) == 4:
    copy(parse(args[1]), args[2], args[3])
    exit(0)

  print 'Illegal number of arguments: ' + str(len(args))
  exit(1)

def parse(filename):
  if not (isfile(filename) and access(filename, R_OK)):
    print 'Cannot read from handyfile: ' + filename
    exit(1)

  lines = open(filename).read().splitlines()

  # check for any directives '*'
  parse_directives(lines)

  # ensure all lines start with '-' or '$'
  lines = [l for l in lines if (l.startswith('-')) or l.startswith('$')]

  # chunk into [[-, $, $], [-, $], [-, $, $, $]]
  chunked = [['']]
  for line in lines:
    if line.startswith('-'):
      chunked.append([line])
    elif line.startswith('$'):
      chunked[-1].append(line)
    else:
      print 'Found invalid line start: ' + line
      exit(1)
  
  return chunked

def parse_directives(lines):
  for line in lines:
    if line.startswith('*'):
      directives[line[1:].strip()] = True
    else:
      return

def output(chunked, copyprogram):
  def heading(text):
    '''Customize the appearance of each section heading'''
    return text + '\n' + ('-' * len(text))

  cnt = 1
  for chunk in chunked:
    print heading(chunk[0][1:].strip())
    for cmd in chunk[1:]:
      print str(cnt) + '. ' + cmd[1:].strip()
      cnt += 1
    print ''
  # done with printing, see if we wait for input
  if directives.get(DIRECTIVE_WAIT_FOR_INPUT, False) and copyprogram:
    cmdnum = -1
    try:
      cmdnum = raw_input("[command-number]: ")
    except:
      print ''
      exit(1)

    copy(chunked, copyprogram, cmdnum)



  
def copy(chunked, copyprogram, cmdnum):
  try:
    cmdnum = int(cmdnum)
  except:
    print 'Invalid command number: ' + cmdnum
    exit(1)

  cmds = [cmd for sublist in chunked for cmd in sublist[1:]]
  if cmdnum > len(cmds) or cmdnum < 1:
    print 'Invalid command number: ' + str(cmdnum)
    exit(1)

  cmd = cmds[cmdnum - 1][1:].strip()
  shell = "printf '" + cmd + "' | " + copyprogram
  system(shell)

def usage():
  print 'handy v1.0'
  print 'handy [<handyfile> [<copy program> [<command number>]]]'


if __name__ == '__main__':
  main(argv)
